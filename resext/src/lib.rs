//! **Context-rich error handling for Rust with zero-cost abstractions and zero allocations**
//!
//! This is the primary interface for ResExt. It re-exports the proc-macro as well as other helpers
//! provided by ResExt.
//!
//! # Quick Start
//!
//! ```rust
//! use resext::resext;
//!
//! #[resext(alias = AppRes)]
//! enum AppError {
//!     Io(std::io::Error),
//!     Parse(std::num::ParseIntError),
//! }
//!
//! fn read_config() -> AppRes<String> {
//!     let content = std::fs::read_to_string("config.toml")
//!         .context("Failed to read config file")?;
//!     
//!     let value: i32 = content.trim().parse::<i32>()
//!         .context("Failed to parse config value")?;
//!     
//!     Ok(content)
//! }
//! ```
//!
//! ---
//!
//! # Proc Macro
//!
//! The proc macro provides clean syntax with full customization:
//!
//! ```rust
//! use resext::resext;
//!
//! #[resext(
//!     prefix = "ERROR: ",
//!     delimiter = " -> ",
//!     include_variant = true,
//! )]
//! enum MyError {
//!     Io(std::io::Error),
//!     Fmt { error: std::fmt::Error },
//! }
//! ```
//!
//! ## Attribute Options
//!
//! - `prefix` - String prepended to entire error message
//! - `suffix` - String appended to entire error message
//! - `msg_prefix` - String prepended to each context message
//! - `msg_suffix` - String appended to each context message
//! - `delimiter` - Separator between context messages (default: " - ")
//! - `source_prefix` - String prepended to source error (default: "Error: ")
//! - `include_variant` - Include variant name in Display output (default: false)
//! - `alias` - Custom type alias name which is used for getting the names for other items generated by the proc-macro (default: `Res`)
//! - `buf_size` - Size for the context message byte buffer (default: 64)
//! - `alloc` Enable heap-spilling if context exceeds `buf_size`
//!
//! ---
//!
//! ## `.context()` method
//!
//! Add context to an error.
//!
//! This method can take `&str` or `core::fmt::Arguments<'_>` as a message
//!
//! ### Example:
//!
//! ```rust
//! # use resext_macro::resext;
//! # #[resext] enum Err { Io(std::io::Error) }
//! std::fs::read("file.txt")
//!     .context("Failed to read file");
//! ```
//!
//! ---
//!
//! # Error Display Format
//!
//! Errors are displayed with context chains:
//!
//! ```text
//! Failed to load application
//!  - Failed to read config file
//!  - Failed to open file
//! Error: No such file or directory
//! ```
//!
//! With `include_variant = true`:
//!
//! ```text
//! Failed to load application
//!  - Failed to read config file
//! Error: Io: No such file or directory
//! ```
//!
//! ---
//!
//! # Examples
//!
//! ## Basic Error Handling
//!
//! ```rust
//! use resext::resext;
//!
//! #[resext]
//! enum ConfigError {
//!     Io(std::io::Error),
//!     Utf8(std::string::FromUtf8Error),
//! }
//!
//! fn load_config(path: &str) -> Res<String> {
//!     let content = std::fs::read(path)
//!         .context("Failed to read config")?;
//!     
//!     std::string::String::from_utf8(content)
//!         .context("Failed to parse config")
//! }
//! ```
//!
//! ## Multiple Error Types
//!
//! **Note:** This example is not tested as it's an example of errors from external crates
//!
//! ```rust,ignore
//! use resext::resext;
//!
//! #[resext(alias = ApiResult)]
//! enum ApiError {
//!     Network(reqwest::Error),
//!     Database(sqlx::Error),
//!     Json(serde_json::Error),
//! }
//!
//! async fn fetch_user(id: u64) -> ApiResult<User> {
//!     let response = reqwest::get(format!("/users/{}", id))
//!         .await
//!         .context(format_args!("Failed to fetch user: {}", id))?;
//!     
//!     let user = response.json()
//!         .await
//!         .context("Failed to parse user data")?;
//!     
//!     Ok(user)
//! }
//! ```
//!

pub use resext_macro::resext;

pub mod __private {
    pub trait ToContext {}

    impl ToContext for &str {}
    impl ToContext for core::fmt::Arguments<'_> {}
}
