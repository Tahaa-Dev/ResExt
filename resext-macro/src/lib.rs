//! Procedural macro for resext.
//!
//! This crate provides the `#[resext]` proc-macro attribute for ergonomic error handling.
//! It is not meant to be used directly - use the `resext` crate instead.
//!
//! # Overview
//!
//! The proc macro generates all necessary error handling code from a simple attribute:
//!
//! ```rust
//! use resext_macro::resext;
//!
//! #[resext]
//! enum MyError {
//!     Io(std::io::Error),
//!     Utf8(core::str::Utf8Error),
//! }
//! ```
//!
//! This expands to approximately 300 lines of boilerplate including:
//!
//! - `Display`, `Debug` and `Error` trait implementations
//! - Wrapper struct with inline, zero-alloc context storage
//! - Trait with context methods
//! - `From<E>` implementations for automatic conversion
//! - Type alias for `Result<T, ResErr>`
//!
//! # Attribute Options
//!
//! See the [resext crate documentation](https://docs.rs/resext) for detailed
//! information on all available options.

use proc_macro::TokenStream;
use quote::{ToTokens, quote};
use syn::{
    Data, DeriveInput, Error, Ident, LitBool, LitStr, parse::Parse, parse_macro_input,
    spanned::Spanned,
};

/// Generate error handling boilerplate for an enum.
///
/// # Usage
///
/// Basic usage with default settings:
///
/// ```rust
/// use resext_macro::resext;
///
/// #[resext(alias = Resext)]
/// enum MyError {
///     Io(std::io::Error),
///     Parse(std::num::ParseIntError),
/// }
/// ```
///
/// With custom formatting:
///
/// ```rust
/// use resext_macro::resext;
///
/// #[resext(
///     prefix = "ERROR: ",
///     delimiter = " -> ",
///     include_variant = true
///     alias = MyRes
/// )]
/// enum MyError {
///     Fmt(std::fmt::Error),
///     EnvVar(std::env::VarError),
/// }
/// ```
///
/// ---
///
/// # Options
///
/// - `prefix` - Prepend to all error messages
/// - `suffix` - Append to all error messages
/// - `msg_prefix` - Prepend to each context message
/// - `msg_suffix` - Append to each context message
/// - `delimiter` - Separator between context messages | default: " - " (NOTE: the delimiter always includes a newline before it, e.g. if delimiter = " - ", then messages will have "\n - " between them, not just " - ")
/// - `source_prefix` - Prepend to underlying error (default: "Error: ")
/// - `include_variant` - Show variant name in output (default: false)
/// - `alias` - Custom type alias name which is used for getting the names for other items generated by the proc-macro (default: `Res`)
/// - `buf_size` - Size for the context message byte buffer (default: 64)
/// - `std` - Enable std-only features like `.or_exit()` macro
/// - `alloc` Enable heap-spilling if context exceeds `buf_size`, this attribute requires a global allocator / importing `extern crate alloc`
///
/// ---
///
/// # Examples
///
/// ```rust
/// use resext_macro::resext;
///
/// #[resext(alias = AppResult)]
/// enum AppError {
///     Io(std::io::Error),
///     EnvVar(std::env::VarError),
/// }
///
/// fn example() -> AppResult<()> {
///     std::fs::read("file.txt")
///         .context("Failed to read file")?;
///     Ok(())
/// }
/// ```
#[proc_macro_attribute]
pub fn resext(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as DeriveInput);
    let args = parse_macro_input!(attr as ResExtArgs);

    let enum_name = &input.ident;
    let vis = &input.vis;

    let alias = args.alias.unwrap_or_else(|| quote! { Res });
    let struct_name = quote::format_ident!("{}Err", alias.to_string());
    let buf_name = quote::format_ident!("{}Buf", alias.to_string());
    let trait_name = quote::format_ident!("{}Ext", alias.to_string());

    let std = args.std;
    let alloc = args.alloc;

    let variants = match &input.data {
        Data::Enum(data) => &data.variants,
        _ => {
            return Error::new(input.ident.span(), "`#[resext]` can only be applied to enums")
                .to_compile_error()
                .into();
        }
    };

    let include_variant = args.include_variant;
    let mut errors: Option<Error> = None;
    let display_match_arms = variants.iter().map(|variant| {
        let variant_name = &variant.ident;

        match &variant.fields {
            syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {
                if include_variant {
                    quote! {
                        #enum_name::#variant_name(var) => write!(f, "{}: {}", stringify!(#variant_name), var),
                    }
                } else {
                    quote! {
                        #enum_name::#variant_name(var) => write!(f, "{}", var),
                    }
                }
            }

            syn::Fields::Named(fields) if fields.named.len() == 1 => {
                let variant_field = fields.named[0].ident.as_ref().unwrap();

                if include_variant {
                    quote! {
                        #enum_name::#variant_name { #variant_field } => write!(f, "{}: {}: {}", stringify!(#variant_name), stringify!(#variant_field), #variant_field),
                    }
                } else {
                    quote! {
                        #enum_name::#variant_name { #variant_field } => write!(f, "{}", #variant_field),
                    }
                }
            }

            syn::Fields::Unit => {
                quote! {
                    #enum_name::#variant_name => write!(f, "{}", stringify!(#variant_name)),
                }
            }

            _ => {
                let error = Error::new(
                    variant.fields.span(),
                    "enum variants used in `#[resext]` can only have 1 field",
                );

                match &mut errors {
                    Some(err) => err.combine(error),
                    None => errors = Some(error),
                };

                quote! {}
            }
        }
    });

    let from_impls = variants.iter().filter_map(|variant| {
        let variant_name = &variant.ident;

        match &variant.fields {
            syn::Fields::Unnamed(fields) if fields.unnamed.len() == 1 => {
                let field_type = &fields.unnamed[0].ty;

                Some(quote! {
                    impl From<#field_type> for #enum_name {
                        fn from(value: #field_type) -> Self {
                            Self::#variant_name(value)
                        }
                    }

                    impl From<#field_type> for #struct_name {
                        fn from(value: #field_type) -> Self {
                            Self { msg: #buf_name::new(), source: #enum_name::#variant_name(value) }
                        }
                    }
                })
            }

            syn::Fields::Named(fields) if fields.named.len() == 1 => {
                let field_name = fields.named[0].ident.as_ref().unwrap();
                let field_type = &fields.named[0].ty;

                Some(quote! {
                    impl From<#field_type> for #enum_name {
                        fn from(value: #field_type) -> Self {
                            Self::#variant_name { #field_name: value }
                        }
                    }

                    impl From<#field_type> for #struct_name {
                        fn from(value: #field_type) -> Self {
                            Self { msg: #buf_name::new(), source: #enum_name::#variant_name { #field_name: value } }
                        }
                    }
                })
            }

            _ => None,
        }
    });

    let ext_methods_def = {
        if std {
            quote! {
                /// Exit the process with the given code if the result is an error.
                ///
                /// Useful for CLI applications that want to exit on critical errors.
                ///
                /// This is an std-only method as it uses `eprintln!()` and
                /// `std::process::exit()`
                ///
                /// # Examples
                ///
                /// ```rust,ignore
                /// let config = load_config().or_exit(1);
                /// ```
                #[cfg(not(doc))]
                fn or_exit(self, code: i32) -> T;

                /// Like `or_exit` but prints a custom message before exiting.
                ///
                /// This is an std-only method as it uses `eprintln!()` and
                /// `std::process::exit()`
                ///
                /// # Examples
                ///
                /// ```rust,ignore
                /// let data = load_critical_data()
                ///     .better_expect(|| "FATAL: Cannot start without data", 1);
                /// ```
                #[cfg(not(doc))]
                fn better_expect<M: core::fmt::Display, F: FnOnce() -> M>(self, f: F, code: i32) -> T;

                /// Write error to writer on error and return `None` or return `Some(T)`
                ///
                /// Writer needs to implement `std::io::Write`, so it's an std-only method
                ///
                /// # Examples
                ///
                /// ```rust,ignore
                /// let mut writer = BufWriter::new(stdout());
                /// let data: Option<Data> = get_data().write_log(&mut writer);
                ///
                /// match data {
                ///     Some(data) => data,
                ///     None => Data::new(),
                /// }
                /// ```
                #[cfg(not(doc))]
                fn write_log<W: std::io::Write>(self, writer: &mut W) -> Option<T>;

                /// Write error to writer on error and return `None` or return `Some(T)`
                ///
                /// Writer needs to implement `core::fmt::Write`
                ///
                /// # Examples
                ///
                /// ```rust,ignore
                /// let mut writer = alloc::string::String::new("");
                /// let data: Option<Data> = get_data().write_log(&mut writer);
                ///
                /// match data {
                ///     Some(data) => data,
                ///     None => Data::new(),
                /// }
                /// ```
                #[cfg(not(doc))]
                fn fmt_log<F: core::fmt::Write>(self, writer: &mut F) -> Option<T>;
            }
        } else {
            quote! {
                /// Write error to writer on error and return `None` or return `Some(T)`
                ///
                /// Writer needs to implement `core::fmt::Write`
                ///
                /// # Examples
                ///
                /// ```rust,ignore
                /// let mut writer = alloc::string::String::new("");
                /// let data: Option<Data> = get_data().write_log(&mut writer);
                ///
                /// match data {
                ///     Some(data) => data,
                ///     None => Data::new(),
                /// }
                /// ```
                #[cfg(not(doc))]
                fn fmt_log<F: core::fmt::Write>(self, writer: &mut F) -> Option<T>;
            }
        }
    };

    let ext_methods_impl = {
        if std {
            quote! {
                fn or_exit(self, code: i32) -> T {
                    match self {
                        Ok(ok) => ok,
                        Err(err) => {
                            eprintln!("{}", err);
                            std::process::exit(code);
                        }
                    }
                }

                fn better_expect<M: core::fmt::Display, F: FnOnce() -> M>(self, f: F, code: i32) -> T {
                    match self {
                        Ok(ok) => ok,
                        Err(err) => {
                            eprintln!("{}\nError: {}", f(), err);
                            std::process::exit(code);
                        }
                    }
                }

                fn write_log<W: std::io::Write>(self, mut writer: &mut W) -> Option<T> {
                    match self {
                        Ok(ok) => Some(ok),
                        Err(err) => {
                            let res = write!(writer, "{}", err);

                            match res {
                                Ok(_) => {},
                                Err(err) => {
                                    eprintln!("{}", err);
                                }
                            }

                            None
                        }
                    }
                }

                fn fmt_log<F: core::fmt::Write>(self, mut writer: &mut F) -> Option<T> {
                    match self {
                        Ok(ok) => Some(ok),
                        Err(err) => {
                            let res = write!(writer, "{}", err);

                            match res {
                                Ok(_) => {}
                                Err(err) => {
                                    eprintln!("{}", err);
                                }
                            }

                            None
                        }
                    }
                }
            }
        } else {
            quote! {
                fn fmt_log<F: core::fmt::Write>(self, mut writer: &mut F) -> Option<T> {
                    match self {
                        Ok(ok) => Some(ok),
                        Err(err) => {
                            let _ = write!(writer, "{}", err);
                            None
                        }
                    }
                }
            }
        }
    };

    let prefix = args.prefix.unwrap_or_default();
    let suffix = args.suffix.unwrap_or_default();
    let msg_prefix = args.msg_prefix.unwrap_or_default();
    let msg_suffix = args.msg_suffix.unwrap_or_default();
    let delimiter = args.delimiter.unwrap_or_else(|| String::from(" - "));
    let source_prefix = args.source_prefix.unwrap_or_else(|| String::from("Error: "));
    let buf_size = args.buf_size.unwrap_or(64);

    let export_macro = {
        match vis {
            &syn::Visibility::Inherited => quote! {},

            _ => {
                quote! {
                    #[macro_export]
                }
            }
        }
    };

    let gen_buf = {
        if !alloc {
            quote! {
                struct #buf_name {
                    curr_pos: u16,
                    buf: [u8; #buf_size],
                    truncate: bool,
                }

                impl #buf_name {
                    fn new() -> Self {
                        Self { buf: [0; #buf_size], curr_pos: 0, truncate: false }
                    }

                    fn get_slice(&self) -> &[u8] {
                        &self.buf[..self.curr_pos as usize]
                    }

                    fn is_empty(&self) -> bool {
                        self.curr_pos == 0
                    }

                    fn truncate(&self) -> bool {
                        self.truncate
                    }
                }

                impl core::fmt::Write for #buf_name {
                    fn write_str(&mut self, s: &str) -> core::fmt::Result {
                        let bytes = s.as_bytes();
                        let pos = self.curr_pos as usize;
                        let cap = #buf_size - pos;

                        let limit = if cap < bytes.len() {
                            self.truncate = true;
                            cap
                        } else {
                            bytes.len()
                        };

                        let to_copy = match bytes[..limit]
                            .iter()
                            .rposition(|&b| (b & 0xC0) != 0x80)
                        {
                            Some(start_of_last_char) => {
                                let last_char_byte = bytes[start_of_last_char];
                                let width = match last_char_byte {
                                    0..=127 => 1,
                                    192..=223 => 2,
                                    224..=239 => 3,
                                    240..=247 => 4,
                                    _ => 1,
                                };
                                if start_of_last_char + width <= limit {
                                    start_of_last_char + width
                                } else {
                                    start_of_last_char
                                }
                            }
                            None => 0,
                        };

                        self.buf[pos..pos + to_copy].copy_from_slice(&bytes[..to_copy]);
                        self.curr_pos += to_copy as u16;

                        Ok(())
                    }
                }
            }
        } else {
            quote! {
                enum #buf_name {
                    Stack { buf: [u8; #buf_size], curr_pos: u16 },
                    Heap(alloc::vec::Vec<u8>),
                }

                impl #buf_name {
                    fn new() -> Self {
                        Self::Stack { buf: [0; #buf_size], curr_pos: 0 }
                    }

                    fn get_slice(&self) -> &[u8] {
                        match self {
                            Self::Stack { buf, curr_pos } => &buf[..*curr_pos as usize],
                            Self::Heap(buf) => buf,
                        }
                    }

                    fn truncate(&self) -> bool {
                        false
                    }

                    fn is_empty(&self) -> bool {
                        match self {
                            Self::Heap(buf) => buf.is_empty(),
                            Self::Stack { buf: _, curr_pos } => *curr_pos == 0,
                        }
                    }
                }

                impl core::fmt::Write for #buf_name {
                    fn write_str(&mut self, s: &str) -> core::fmt::Result {
                        match self {
                            Self::Heap(buf) => buf.extend_from_slice(s.as_bytes()),
                            Self::Stack { buf, curr_pos } => {
                                let bytes = s.as_bytes();
                                let pos = *curr_pos as usize;
                                let cap = #buf_size - pos;

                                if bytes.len() > cap {
                                    let mut vec = alloc::vec::Vec::new();
                                    vec.reserve_exact(pos + bytes.len());

                                    vec.extend_from_slice(&buf[..pos]);
                                    vec.extend_from_slice(bytes);

                                    *self = #buf_name::Heap(vec);
                                } else {
                                    buf[pos..pos + bytes.len()].copy_from_slice(bytes);
                                    *curr_pos += bytes.len() as u16;
                                }
                            }
                        }

                        Ok(())
                    }
                }
            }
        }
    };

    let expanded = quote! {
        #[derive(Debug)]
        #input

        impl core::fmt::Display for #enum_name {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self {
                    #(#display_match_arms)*
                }
            }
        }

        /// Wrapper type that holds your error with optional context messages.
        ///
        /// This type is automatically created when you use `.context()` or
        /// `.with_context()` on a Result.
        #[cfg(not(doc))]
        #vis struct #struct_name {
            msg: #buf_name,
            #vis source: #enum_name
        }
        impl core::error::Error for #struct_name {}


        impl core::fmt::Write for #struct_name {
            fn write_str(&mut self, s: &str) -> core::fmt::Result {
                self.msg.write_str(s)
            }
        }

        impl core::fmt::Display for #struct_name {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if self.msg.is_empty() {
                    write!(f, "{}{}{}", #source_prefix, &self.source, #suffix)
                } else {
                    write!(
                        f,
                        "{}{}{}\n{}{}{}",
                        #prefix,
                        unsafe { core::str::from_utf8_unchecked(&self.msg.get_slice()) },
                        if self.msg.truncate() { "..." } else { "" },
                        #source_prefix,
                        self.source,
                        #suffix,
                    )
                }
            }
        }

        impl core::fmt::Debug for #struct_name {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                if self.msg.is_empty() {
                    write!(f, "{}{:?}{}", #source_prefix, &self.source, #suffix)
                } else {
                    write!(
                        f,
                        "{}{}{}\n{}{:?}{}",
                        #prefix,
                        unsafe { core::str::from_utf8_unchecked(&self.msg.get_slice()) },
                        if self.msg.truncate() { "..." } else { "" },
                        #source_prefix,
                        self.source,
                        #suffix,
                    )
                }
            }
        }

        impl #struct_name {
            /// Helper method for constructing #struct_name without using `.context()` or
            /// `.with_context()` on a Result.
            ///
            /// # Examples
            ///
            /// ```rust,ignore
            /// ResErr::new("Failed to read file", std::io::Error::other(""));
            /// ```
            #vis fn new<E>(msg: &str, source: E) -> Self where #enum_name: From<E> {
                use core::fmt::Write;
                let mut buf = #buf_name::new();
                let _ = buf.write_str(msg);
                Self { msg: buf, source: #enum_name::from(source) }
            }
        }

        impl From<#enum_name> for #struct_name {
            fn from(value: #enum_name) -> Self {
                Self { msg: #buf_name::new(), source: value }
            }
        }

        #(#from_impls)*

        /// Extension trait for adding context to Result types.
        ///
        /// Automatically implemented for all `Result<T, E>` where `E` can be
        /// converted into your error enum.
        ///
        /// # Examples
        ///
        /// ```rust,ignore
        /// std::fs::read("file.txt")
        ///     .context("Failed to read file")?;
        /// ```
        #[cfg(not(doc))]
        #vis trait #trait_name<'r, T> {
            /// Add a static context message to an error.
            ///
            /// The message is only allocated if an error occurs.
            ///
            /// # Examples
            ///
            /// ```rust,ignore
            /// std::fs::read("config.toml")
            ///     .context("Failed to read config")?;
            /// ```
            #[cfg(not(doc))]
            fn context(self, msg: &str) -> Result<T, #struct_name>;

            /// Add a dynamic context message (computed only on error).
            ///
            /// Use this when the context message needs runtime information.
            ///
            /// # Examples
            ///
            /// ```rust,ignore
            /// std::fs::read(path)
            ///     .with_context(|| format!("Failed to read: {}", path))?;
            /// ```
            #[cfg(not(doc))]
            fn with_context(self, args: core::fmt::Arguments<'r>) -> Result<T, #struct_name>;

            #ext_methods_def
        }

        impl<'r, T> #trait_name<'r, T> for Result<T, #struct_name> {
            fn context(self, msg: &str) -> Result<T, #struct_name> {
                match self {
                    Ok(ok) => Ok(ok),
                    Err(mut err) => {
                        use core::fmt::Write;
                        if err.msg.is_empty() {
                            let _ = write!(&mut err, "{}", msg);
                        } else {
                            let _ = write!(&mut err, "\n{}{}{}{}", #delimiter, #msg_prefix, msg, #msg_suffix);
                        }
                        Err(err)
                    }
                }
            }

            fn with_context(self, args: core::fmt::Arguments<'r>) -> Result<T, #struct_name> {
                match self {
                    Ok(ok) => Ok(ok),
                    Err(mut err) => {
                        use core::fmt::Write;
                        if err.msg.is_empty() {
                            let _ = write!(&mut err, "{}", args);
                        } else {
                            let _ = write!(&mut err, "\n{}{}{}{}", #delimiter, #msg_prefix, args, #msg_suffix);
                        }
                        Err(err)
                    }
                }
            }

            #ext_methods_impl
        }

        impl<'r, T, E: core::fmt::Display> #trait_name<'r, T> for Result<T, E>
        where
            #enum_name: From<E>,
        {
            fn context(self, msg: &str) -> Result<T, #struct_name> {
                match self {
                    Ok(ok) => Ok(ok),
                    Err(err) => {
                        use core::fmt::Write;
                        let mut buf = #buf_name::new();
                        let _ = write!(&mut buf, "{}", msg);
                        Err(#struct_name { msg: buf, source: err.into() })
                    }
                }
            }

            fn with_context(self, args: core::fmt::Arguments<'r>) -> Result<T, #struct_name> {
                match self {
                    Ok(ok) => Ok(ok),
                    Err(err) => {
                        use core::fmt::Write;
                        let mut buf = #buf_name::new();
                        let _ = write!(&mut buf, "{}", args);
                        Err(#struct_name { msg: buf, source: err.into() })
                    }
                }
            }

            #ext_methods_impl
        }

        /// Macro for returning `Err()` results with context easily
        ///
        /// # Examples
        ///
        /// ```rust,ignore
        /// fn return_error(file_name: &str) -> Res<()> {
        ///     Res!(std::io::Error::other("I/O Error"), "Failed to read file: {}", file_name);
        /// }
        /// ```
        #[cfg(not(doc))]
        #[allow(unused_macros)]
        #export_macro
        macro_rules! #alias {
            ($src:expr, $fmt:expr, $($arg:tt)*) => {
                {
                    use core::fmt::Write;
                    let mut buf = #buf_name::new();
                    let _ = write!(&mut buf, "{}", format_args!($fmt, $($arg)*));
                    return Err(#struct_name { msg: buf, source: #enum_name::from($src) });
                }
            };

            ($src:expr, $msg:expr) => {
                {
                    use core::fmt::Write;
                    let mut buf = #buf_name::new();
                    let _ = write!(&mut buf "{}", format_args!($fmt));
                    return Err(#struct_name { msg: buf, source: #enum_name::from($src) });
                }
            };
        }

        #vis type #alias<T> = Result<T, #struct_name>;

        #gen_buf
    };

    if let Some(error) = errors {
        TokenStream::from(error.to_compile_error())
    } else {
        TokenStream::from(expanded)
    }
}

struct ResExtArgs {
    prefix: Option<String>,
    suffix: Option<String>,
    msg_prefix: Option<String>,
    msg_suffix: Option<String>,
    delimiter: Option<String>,
    source_prefix: Option<String>,
    include_variant: bool,
    alias: Option<proc_macro2::TokenStream>,
    buf_size: Option<usize>,
    std: bool,
    alloc: bool,
}

impl Parse for ResExtArgs {
    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
        let mut args = ResExtArgs {
            prefix: None,
            suffix: None,
            msg_prefix: None,
            msg_suffix: None,
            delimiter: None,
            source_prefix: None,
            include_variant: false,
            alias: None,
            buf_size: None,
            std: false,
            alloc: false,
        };

        while !input.is_empty() {
            let key: Ident = input.parse()?;
            input.parse::<syn::Token![=]>()?;

            match key.to_string().as_str() {
                "prefix" => {
                    let value: LitStr = input.parse()?;
                    args.prefix = Some(value.value())
                }

                "suffix" => {
                    let value: LitStr = input.parse()?;
                    args.suffix = Some(value.value())
                }

                "msg_prefix" => {
                    let value: LitStr = input.parse()?;
                    args.msg_prefix = Some(value.value())
                }

                "msg_suffix" => {
                    let value: LitStr = input.parse()?;
                    args.msg_suffix = Some(value.value())
                }

                "delimiter" => {
                    let value: LitStr = input.parse()?;
                    args.delimiter = Some(value.value())
                }

                "source_prefix" => {
                    let value: LitStr = input.parse()?;
                    args.source_prefix = Some(value.value())
                }

                "alias" => {
                    let value: Ident = input.parse()?;
                    args.alias = Some(value.into_token_stream());
                }

                "buf_size" => {
                    let value: syn::LitInt = input.parse()?;
                    args.buf_size = Some(value.base10_parse()?);
                }

                "std" => {
                    let value: LitBool = input.parse()?;
                    args.std = value.value();
                }

                "alloc" => {
                    let value: LitBool = input.parse()?;
                    args.alloc = value.value();
                }

                "include_variant" => {
                    let value: LitBool = input.parse()?;
                    args.include_variant = value.value();
                }

                _ => {
                    return Err(Error::new(
                        key.span(),
                        format!(
                            "unknown argument passed to proc-macro attribute `#[resext]`: {}",
                            key
                        ),
                    ));
                }
            }

            if input.peek(syn::Token![,]) {
                input.parse::<syn::Token![,]>()?;
            }
        }

        Ok(args)
    }
}
